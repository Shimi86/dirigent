BUG: Dirigent seems sets DIRIGENT_PLAN to the locally selected plan on the agent on the target machine, not to the plan selected on the agent the start commadn was issued from.

[DONE] "Kill all" button killing all apps, plans, restarters, everything.

[DONE] "Reload config" operation that just reloads the SharedConfig.xml without the need to shutdown all the apps. Should be failure proof - no reload if there is a bug in the config etc. To be used for  little changes not breaking much the plan/app structure so that the apps can remain running. On Master, monitor the shared config file for changes and reload automatically (leaving the already strated plans and apps running).

[DONE] "Shutdown" operation that terminates all dirigent agents. Should optionally kill all running local apps started by each dirigent agent.

[DONE] "Reinstall" operation that allows to replace the dirigent executables.
 - Each agent launches a new restarter process knowing how to run the agent again on the same computer with same options.
 - All agents terminate, allowing to replace their executables.
 - Restarter process shows a button to relaunch the agent. If the relaunch is succesfull, the restarter terminates.
 - Restartes might communicate with each other (via UDP broadcast for example) to invoke the relaunch operation on all stations at once (advanced solution for later)

[DONE] Master, if run from agent, receives agent's pid on command line to indicate that the master does not need to open its own updater/restarted app because it is handled by the agent's one already.
 
[DONE] "Terminate Dirigent" operation that kills dirigent agents on all computers. 
 
[DONE] Allow DIRIGENT_MASTER_IP variables (and maybe others) to be used in app command lines.

Allow defining internal variables in dirigent's shared config, usable for expansion on multiple places in the config. Consider switching to Lua based configuration.
 
BUG: if a bunch of DirigentAgentCmd.exe apps are started at once (each sending one KillPlan command), sometimes one or two of the plans are left running. Two obervations: 1. Sometimes the Dirigent.master does not receive the command. 2. Sometimes the master receives the command and forwards it to the agent but the agent does not receive it. There must be some singnificat problem in network communnication between Dirigent client and Dirigent master.... How to workaround this?  Allow AgentCmd to read the list of commands from a file or a long list from XML? Or instead of using AgentCmd try using Dirigent.CLI.Telnet.exe and add the processing of command from a file. In both case improve AgentCmd/CLI.Telnet logging to output more useful info (what command was processed and sent).

Define one plan as the default. Use it to initialize the list of all apps (initial order, initial configuration). Before switching to a new plan, always reset the app settings to the one from the default plan (so if the new plan does not contain an app, such app will be reset to the settings from the default plan).

Inter-plan dependencies. Do not check if the dependency exist in the same plan. It should exist in at least one of all plans. If the dependency app have never been started yet, it shall be treated as unitialized.

Reload SharedConfig tray-icon option. Sends reset command to Master who in turn sends reset to to all agents and then reloads the Sharedconfig and sends new plan pack. On reset agents kill all their local apps so the ones started later on will be run with the settings from the new plan.

Fix crash if Master console opened but terminated via Ctrl+C.

Color-coding of app states (Killed=gray, FailedToSTart=red, Running=green, Planned=yellow, Initializing=orange, Not running=black, Terminated with exitcode<>0= red)

Color-coding of plan states (Success = green, None=black, Killing=gray, Failure=red, InProgress=orange)

Kill all running local apps on exit.

Telnet: add 'quit' / 'exit' command.
Telnet: take commanda from command line, exit after sending them (do not wait for confirmation). Take commands from std input.

[NOTABUG] Before starting the last app from the plan (a volatile app) the plan reports Failure for a short time until that volatile app gets started.[Update] It's actually not a bug. In this case the timeout happened, moving the plan state to Failure, but then the app started and plan status went Success again.

[FIXED] WindowPoppedUp init detector hands on process that creates a top level window but does not process window messages for it. SendMessage(GET_TEXT..) never returns. We might try SendMessageTimeout asynchronously to avoid blocking. [UODATE] we use timeout 10msec

[FIXED] WindowPoppedUp init detector does not enumerate IgManager's console window... [UPDATE] now adding the main window explicitly, not just the windows enumerated using the thread-based search.

Scan processes to adopt at regular intervals (not just on Launch request) to indicate that Dirigent konws about them; show status "Running (adopted)".

Warn if more agents with same MachineId connects to same master. Send warning message with IP addresses of all the agents with same MachineId.
See https://stackoverflow.com/questions/527676/identifying-the-client-during-a-net-remoting-invocation/527756 for how to get client IP address :-(

Warn if agents with different build id connects to same master. Send warning message with IP addresses of all the agents with same MachineId.

[DONE] With the default plan set at startup in mode master==1 the checkboxes can't be unchecked. After selecting another plan the checkboxes start working.

[DONE] Fix: Dirigent master crashes on starting a process whose directory is invalid, after showing proper error message on the node that issued the command.


MultiPlan changes
 - Multiple plans can run simultanously (expected not to collide with each other). No longer the concept of a globally selected single plan. Selected plan concept now works only in a single GUI agent as its internal state, not globally across agents anymore.
 - IDirigentControl
	- [DONE] SelectPlan works only in local agent's scope
	- [DONE] GetCurentPlan works only in local agent's scope
	- [DONE] each plan manipulation method takes ILaunchPlan as parameter

 - TimeOut for plan operations
   - [DONE] Starting: success when all apps have been launched and those that shall be running are still running
 
 - [REJECTED] Plan control interface (Start/Kill/Restart) move to ILaunchPlan. Only plan enumaration remains in IDirigentControl
 - [REJECTED] Plan status interface (GetPlanState returning both OpMode and OpStatus) move to ILaunchPlan.
 - [DONE] Plan interpretter classes (LaunchDepsChecker, LaunchSequencer) are instantiated per plan, not as a single instance. Probably requiring local op storage for additional plan info separately from planRepo (i.e. not part of ILaunchPlan), something like planRuntimeInfo map indexed by plan name.
 - A plan has new operation state attributes
   - [REJECTED] OpMode - None/Kill/Start/Restart... what most recent operation was perfromaned with the plan [UPDATE] Just whether the plan is running or not suffices. Kill is immediate, restart is a sequence of Kill and Start.
   - [DONE] OpStatus - None/OK/InProgress/Failed ... what is the
   - These are shared info needed by all participants and shall be part of ILaunchPlan interface and communicated to all agents.
   - [DONE] Who owns the OpMode? Can be stored locally on each agent [YES], synchronized just by a command message StartPlan, StopPlan, KillPlan, RestartPlan? For late connected agents we need a central MasterAgent as the command message is missed... [DONE]
   - [DONE] Who determines the status of a plan? Plan status should be derived from the status of its applications, locally on each agent, any time. No central storage required... 
   Concept of Master Agent is required?? [NO]
   - [NOT REQUIRED IN DECENTRALIZED DESIGN?] New structure PlanState containing the current state of a plan. New message PlansStateMessage containing dictionary of states of all plans (like AppsStateMessage). This is necessary only for client connected after the plan was already started. Who shall send this message? Selected agent, the one that has to run always - the MasterAgent.    

 - MasterAgent
   - An agent with IDirigentControl interface, running a message server service locally in a single application if configured so. May have local operations.
   - Master's network server should be converted into a library that is linked to Master as well as to MasterAgent.
   - [DONE] Has telnet-style interface for remote control.
   - Owner of plan state? Better to do it in a centralized way...
 

Computer name as agent's machineId  automatically? If machineId from config/cmdline is empty, use computer name
 
Dirigent config defined "macro variables" that can be used within dirigent config in similar way as environment variables. Config-variables will be resolved first and can be overriden by envvars.
  - whole-config scope
        <Shared>
            <Set Variable="xyz">
  - launch plan scope
        <Shared>
            <Plan Name="plan1">
                <Set Variable="xyz">
    
  - application definition local (%APPNAME%)

Autoupdate feature: on network message locate new binaries (in some subdir), run an updater process with instructions how to update and how to restart after that. Updater process copies binaries from the subdir and re-launches the agent, now running from new updated binaries.
  
Define config variables on agent's command line

Fix: Object reference not set exception sometimes when launching a process

Fix: Application sometimes left open and forgotten by dirigent, still running and can not be killed by dirigent. Happens for example if the app is started via shell and the KILL command comes just when the shell is starting the app. The shell gets killed, the started app does not.

Option to redirect standard and error output of a launched process.

[DONE] Add InitDetector that fires when a process-owned window appears with title matching given regexp. [DONE]

[DONE] Support for relative working directory specification for a process, taking dirigent's working directory as a basis. [DONE]

Review the AppState flags, make it less confusing. Use one application state enum + just a few additional flags..

Application Multiselect & bulk operations in the Control GUI.

New option for the apps: `KillOnAdopt`. If an application is already running when starting a plan that contains an app with the same name, the running one is killed. This is usefull if the app has the same name but different attributes and we want it to be started with those attributes from the new plan. Or if the dirigent agent crashes and we want it to regain control after restarting.

Remote monitoring of machines. Shutting them down, starting them up. Works only if the machines are listed in the shared config together with their MAC addresses.

Remote execution of ANY command on selected machine(s). 

Support for applications that are never started automatically, just manually (always excluded from plan).

[DONE] Support for disabling an application before starting a launch plan. NOT MUCH USED

Support for multiple retries when launching a problematically starting application.

Failure timeout for app bootup detector.

[DONE] One agent to run/keep alive master process automatically (command line option --IsMaster 1)

[DONE] Prevent multiple instances of agent with the same name (machineId:port)

[NOT IMPORTANT] Send launch plan over the network as XML string and parse it on each endpoint - no need to have comparable AppDefs etc. NOT MUCH NEEDED

[DONE] Script based procesing for agentcmd. REPLACED WITH MULTIPLE SEMICOLON SEPARATED COMMANDS

[NOT IMPORTANT] Build installer 

[DONE] Multiple independent <WindowPos /> sections per single application to control multiple application windows.

[DONE] Show "??? (disconnected)" as the status for a remote app if agent not connected to master. Also disallow Launch/Kill for remote apps in this case. This should avoid the error Machineid 'm2.a' is not the one of this computer. Happens when trying to kill a remote app in local disconnected mode.

[DONE] Show "??? (no info for xx secs)" as the status for a remote app if no new updates have come from the remote agent for a longer period of time (longer than normal update period).

[DONE] Autorestart an app after crash.

[REJECTED] Run server process om master machine automatically on agent start. Reset the server process if server already running.
[DONE] Allow for non-windowed mode (console app for linux, windows service).
[DONE] Extract the preparation of agent configuration into a separate class and use it for non-windowed mode.
[DONE] Separate main GUI form into a reusable library, requiring just IDirigentControl.
[DONE] NetworkOperations to use just IDirigentCOntrol instead of LocalOperations.
[DONE] Two flavors of GUI - one with embedded agent and one that connect remotely to a session without starting its own agent instance.

[DONE] Make the master know the shared config and provide it to agents. Synchronize shared configuration upon connection to master. Resolve conflicts with locally stored config.

[DONE] Make shared config at agent optional. Make the use of it only until the connection to master is estabilished.

[DONE] Make the master know the current lauch plan and provide it to agents. Agent loads it upon connection to master.

[DONE] Add log4net logging. In non-windowed mode, log the exceptions using log4net.

[DONE] Add command line options to specify the config files, initial launch plan to follow etc.

[REJECTED] Server as windows service (maybe through a 3rd party service loader app??) Or just TrayApp will be used instead? Service would allow starting processes on without any user logged in (which is not much useful).

[DONE] Combine multiple operational modes into one single agent app (local, networked, tray GUI app...)

[DONE] Create commandline tool for sending commands to agents.

[DONE] Support for autorestart of app after unexpected termination. Add crashed app to launch sequencer when crash is detected..

[DONE] Kill whole process tree on StopApp, not just a single process.

[DONE] Support for application windowstyle  attributes (hidden, minimized, maximized)

[DONE] Multiple coexisting plans that share the applications.

[DONE] Support for additional application window attributes (topmost, always on top) - through WindowStyle attribute

[DONE] Generic AppWatchers. Watch the app and do something. COnfigured from XML node which is parsed by AppWatcher, not by a global parser.

[DONE] Support for applying application window position and size shortly after the window with given title appears. Through section <WindowPos titleregexp="\s-\sNotepad" rect="10,50,300,200" screen="1" keep="0" /> 

[DONE] Fix: Dirigent crashes when startupPlan name does not exist in the list of plans

[DONE] Checkbox to exclude app from a plan.
 
 
[DONE] Support for setting the environemt variables before a launch operation or remote command for a plan or individual app.
The variables are set in Dirigent's environment and are inherited by all the apps launched afterwards by the Dirigent. The variables can be used also on the apps' command line (this is an already existing feature).


PLugins for Dirigent. The plugins are separate assemblies in Dirigent's plugin folder . Dirigent agent scans then upon startup and extracts the plugin API from them. Plugins for: init detector, UI startable tools having access to dirigent's API etc.

A plugin tool startable from dirigent's UI, providing support for UI-selectable&editable variable pack to be defined for a plan. User picks the pack from a list box before starting a plan. The variables could be used as command line arguments for processes within the plan. Some variables might be set to "user editable"; those could be edited by the user. The pack name is shown in the agent's toolbar where it could be quickly changed to another pack or opened for variable editing. The variables are set via Dirigent's SetVars API before issuing a StartPlan. Proposed usage: running svn client with arguments on all controlled computers. Several SVN operations might be predefined and easily pickable.


Handle Dirigent.Master's exception when computer is waking up from hibernation. Terminate the app and let the Dirigent.Agent to restart it.

[DONE] KillPlan takes many seconds when there are many (for example 30) apps in a plan.
 - Tested with 30 instances notepad.exe using KillSoftly=0 & TreeKill=0; all killed in no time.
 - Heavier apps are killed sequentially in a blocking way ... make non-blocking!

[DONE] StartPlan containing 30 apps takes long time to run all of them even if SeparationInterval=0
 - processPlan() launches max. one app at a time
 - If SeparationInterval=0, it should start apps at once with no time separation 
 
[DONE] PlanState is reported as "None" immediately after KillPlan although the apps might still be dying slowly.
 - Add new plan state Killing which is set after KillPlan until all apps actually die (disappear from the system).
 - Killing an app should be implemented in a non-blocking manner, no longer blocking further processing of dirigent.Agent before the app terminates.
 - Add new app state Dying which is set while killing an app until the app disappears from the system, then it is cleared.
 - An app is not considered "runnable" until it dies. LaunchApp will do nothing for an app in Dying state.
    - App's launcher instance is not disposed until the app's process disappears from the system. Every tick it checkes if the app 

	
[DONE] RestartApp needs to be implemented in a non-blocking manner. I.e. first it kills the app (in non-blocking manner), wait for the app to die, then launch it again.
 
